or[[i]] = cbind.data.frame(colnames(odds)[-1], as.data.frame(formatC(cbind(odds[i,], orci[,,i]), digits = 3, format = "f"))[-1,])
rownames(or[[i]]) = NULL
colnames(or[[i]]) = c("Variable", "Odds Ratio", "Lower", "Upper")
names(or)[i] = colnames(coeffs)[i]
if(!is.null(waldTest[[i]])){
if(sum(waldTest[[i]]$Variable %in% continousInputs) > 0){
con = waldTest[[i]]$Variable[waldTest[[i]]$Variable %in% continousInputs]
}else{con = NULL}
if(!is.null(categoricalInputs)){
cat = sapply(categoricalInputs,FUN = function(x){
agrep(x, waldTest[[i]]$Variable,  value = T,  max.distance = 0)
}
)
cat2 = unlist(cat)
if(class(cat2) == "matrix"){
cat3 = rep(categoricalInputs, length(cat2))
cat4 = data.frame(original = cat3, model = cat2)
}else{
cat3 = unlist(
sapply(names(unlist(lapply(cat,length))), FUN = function(x){
rep(x,unlist(lapply(cat,length))[[x]])
})
)
cat4 = data.frame(original = cat3, model = cat2)
}
cat5 = apply(cat4, 1, FUN = function(x){
paste0(substr(x[2], start = 1, stop=nchar(x[1])), " (", substr(x[2], start = nchar(x[1])+1, stop=nchar(x[2])), ")")
})
}
coeffs2 = data.frame(Coefficiens = waldTest[[i]]$Variable, stringsAsFactors = FALSE)
rownames(coeffs2) = coeffs2$Coefficiens
coeffs2$Newname = rep(NA, nrow(coeffs2))
for(k in 1:nrow(coeffs2)){
c = as.character(coeffs2$Coefficiens[k])
if(c == "(Intercept)"){coeffs2$Newname[k] = "Intercept"}else if(c %in% con){coeffs2$Newname[k] = c}
}
if(!is.null(categoricalInputs)){
coeffs2[cat2,"Newname"] = cat5
}
waldTest[[i]]$Variable = coeffs2$Newname
}
or[[i]]$Variable = waldTest[[i]]$Variable[-1]
}
storeList <- list()
if ("predictions" %in% store){
predictions = as.data.frame(formatC(current$fitted.values, digits = 3, format = "f"))
names(predictions) <- NULL
storeList[["Predictions"]] <- predictions
}
if ("residuals" %in% store){
residuals = as.data.frame(formatC(current$residuals, digits = 3, format = "f"))
names(residuals) <- NULL
storeList[["Residuals"]] <- residuals
}
} else {
waldTest = NULL
or = NULL
}
predictions = ifelse(prob > cutOff, case, control)
predictions = factor(predictions%*%(1:length(colnames(predictions))), labels = colnames(predictions))
classificationTable = table(df2[,colnames(responseVar)], predictions)
classificationTable = as.data.frame.matrix(classificationTable)
classificationTable = cbind("#" = rownames(classificationTable), classificationTable)
rownames(classificationTable) = NULL
lrTest = list()
for(i in 1:(ncol(df2)-1)){
coeffNames = colnames(df2)[!(colnames(df2) %in% colnames(responseVar))]
effect = coeffNames[i]
lr = lrtest(model, effect)
loglik = formatC(lr$LogLik[2], digits = 3, format = "f")
chisq = formatC(lr$Chisq[2], digits = 3, format = "f")
df = formatC(abs(lr$Df[2]), digits = 0, format = "f")
p = formatC(lr$`Pr(>Chisq)`[2], digits = 3, format = "f")
lrTest[[i]] = cbind.data.frame("Variable" = effect, "Log-likelihood" = loglik, "Chi-square statistic" = chisq, "d.f." = df, "p value" = p)
}
lrTest = do.call(rbind.data.frame, lrTest)
}
if (descriptives){
tbl = table(responseVar)
freq = as.data.frame(tbl)
freq$percent = formatC(freq$Freq/sum(freq$Freq), digits = 3, format = "f")
names(freq) = c(names(responseVar), "n", "%")
if(!is.null(continousInputs)){
splitCon = split(df2[, !names(df2) %in% c(names(responseVar), names(categoricalInputs2))], responseVar)
}else{splitCon = NULL}
if(!is.null(categoricalInputs)){
splitCat = split(df2[, !names(df2) %in% c(names(responseVar), names(continousInputs2))], responseVar)
}else{splitCat = NULL}
descList = list()
freqList = list()
l = if(length(splitCon) != 0){length(splitCon)}else{length(splitCat)}
for (i in 1:l){
if (!is.null(continousInputs)){
variables = continousInputs
if(length(variables) > 1){
n = ldply(splitCon[[i]], .fun = function(x) length(x))[,-1]
mean = ldply(splitCon[[i]], .fun = function(x) formatC(mean(x),digits = 3, format= "f"))[,-1]
sd = ldply(splitCon[[i]], .fun = function(x) formatC(sd(x),digits = 3, format= "f"))[,-1]
median = ldply(splitCon[[i]], .fun = function(x) formatC(median(x),digits = 3, format= "f"))[,-1]
q1 = ldply(splitCon[[i]], .fun = function(x) formatC(quantile(x, 0.25),digits = 3, format= "f"))[,-1]
q3 = ldply(splitCon[[i]], .fun = function(x) formatC(quantile(x, 0.75),digits = 3, format= "f"))[,-1]
min = ldply(splitCon[[i]], .fun = function(x) formatC(min(x),digits = 3, format= "f"))[,-1]
max = ldply(splitCon[[i]], .fun = function(x) formatC(max(x),digits = 3, format= "f"))[,-1]
group = names(splitCon)[i]
}else{
n = length(splitCon[[i]])
mean = as.numeric(formatC(mean(splitCon[[i]]),digits = 3, format= "f"))
sd = as.numeric(formatC(sd(splitCon[[i]]),digits = 3, format= "f"))
median = as.numeric(formatC(median(splitCon[[i]]),digits = 3, format= "f"))
q1 = as.numeric(formatC(quantile(splitCon[[i]], 0.25),digits = 3, format= "f"))
q3 = as.numeric(formatC(quantile(splitCon[[i]], 0.75),digits = 3, format= "f"))
min = as.numeric(formatC(min(splitCon[[i]]),digits = 3, format= "f"))
max = as.numeric(formatC(max(splitCon[[i]]),digits = 3, format= "f"))
group = names(splitCon)[i]
}
desc = as.data.frame(cbind(group, variables,n, mean, sd, median, q1, q3, min, max))
names(desc) = c(names(responseVar), "Variable", "n", "Mean", "Standard deviation", "Median", "Q1", "Q3", "Minimum", "Maximum")
descList[[i]] = desc
}
if (!is.null(categoricalInputs)){
if (dim(categoricalInputs2)[2] == 1){
tblCat = table(splitCat[[i]])
freqCat = as.data.frame(tblCat)
freqCat$percent = formatC(freqCat$Freq/sum(freqCat$Freq), digits = 3, format = "f")
group = names(splitCat)[i]
freqCat = cbind(group, freqCat)
names(freqCat) = c(names(responseVar), names(categoricalInputs2), "n", "%")
} else {
freqCat = apply(splitCat[[i]], 2, as.data.frame(table))
for (f in 1:length(freqCat)){
freqCat[[f]]$percent = formatC(freqCat[[f]]$value.Freq/sum(freqCat[[f]]$value.Freq), digits = 3, format = "f")
group = names(splitCat)[i]
freqCat[[f]] = cbind(group, freqCat[[f]])
names(freqCat[[f]]) = c(names(responseVar), names(freqCat)[[f]], "n", "%")
}
}
freqList[[i]] = freqCat
} else {
freqList = NULL
}}
names(freqList) <- names(splitCat)
if(length(descList) != 0){
descriptives = do.call(rbind.data.frame, descList)
}else{descriptives = NULL}
frequencies <- freqList
# if (!is.null(categoricalInputs)){
#   if (dim(categoricalInputs2)[2] == 1){
#     frequencies = do.call(rbind.data.frame, freqList)
#     rownames(frequencies) <- NULL
#   } else {
#     frequencies = freqList
#   }
# }
}else{
freq = NULL
descriptives = NULL
frequencies = NULL
}
storeList <- as.data.frame.list(storeList)
if (!(nrow(storeList) >= 1)){
storeList <- NULL
}
result = list(tableResult = list(FrequenciesResponse = freq, Descriptives = descriptives, Frequencies = frequencies),
testResult = list(ModelSummaryList = list(CoefficientEstimates = waldTest,
OddsRatio = or, ClassificationTable = classificationTable, lrTest = lrTest,
Store = storeList), categoricalRefs = refs))
result$testResult$ModelSummaryList$ClassificationTable
result$testResult$ModelSummaryList$lrTest
seed = 1234
set.seed(seed)
rule = "DINA"
library(CDM)
library(openxlsx)
attribute = c(6)
item = c(40)
size = c(500)
c = 0.2 ## zayıf korelasyon
Sigma = matrix(c(1,c,c,c,c,c,
c,1,c,c,c,c,
c,c,1,c,c,c,
c,c,c,1,c,c,
c,c,c,c,1,c,
c,c,c,c,c,1), ncol = attribute[k])
seed = 1234
set.seed(seed)
rule = "DINA"
library(CDM)
library(openxlsx)
attribute = c(6)
item = c(40)
size = c(500)
c = 0.2 ## zayıf korelasyon
Sigma = matrix(c(1,c,c,c,c,c,
c,1,c,c,c,c,
c,c,1,c,c,c,
c,c,c,1,c,c,
c,c,c,c,1,c,
c,c,c,c,c,1), ncol = attribute)
m=0.5
mu =  rep(m, ncol(q.matrix))
?CDM::sim.din
q.matrix = read.table("~/Documents/Emine Yavuz/qmatrix/Q6_40.txt")
q.matrix
mu =  rep(m, ncol(q.matrix))
for(s in 1:length(size)){
for(k in 1:length(attribute)){
for(l in 1:length(item)){
path = paste0("~/Documents/Emine Yavuz/qmatrix/Q",attribute[k],"_",item[l],".txt")
q.matrix = read.table(path, header = F)
q.matrix = as.matrix(q.matrix)
# Slipping parameters
slip =runif(item[l], 0, 0.2)
# Guessing parameters
guess =runif(item[l], 0, 0.2)
# sim.din(N=100, q.matrix, guess=rep(0.2, nrow(q.matrix)),
#         slip=guess, rule="DINA")
#
# simdata <- CDM::sim.din(N=100, q.matrix, guess=rep(0.2, nrow(q.matrix)),
#                         slip=guess, mean=rep(0, ncol(q.matrix)), Sigma=diag(1, ncol(q.matrix)),
#                         rule="DINA", alpha=NULL)
resultDINA <- list()
resultDINO <- list()
for(i in 1:100) {
simdata <- CDM::sim.din(N=size[s], q.matrix, guess=rep(0.2, nrow(q.matrix)),
slip=guess, mean= mu, Sigma=Sigma,
rule= rule, alpha=NULL)
### Dina Estimations
Dina<- din(data = simdata$dat, q.matrix = q.matrix, rule = "DINA", seed = seed)
summaryDINA = summary(Dina)
classAccuracyDINA = cdm.est.class.accuracy(Dina)
mean.rmsea = summaryDINA$din.object$mean.rmsea
itemfit.rmsea = summaryDINA$din.object$itemfit.rmsea
loglikelihood = summaryDINA$din.object$loglike
deviance = summaryDINA$deviance
AIC = summaryDINA$AIC
BIC = summaryDINA$BIC
MLE_patt_Pa_est = classAccuracyDINA$statistics$Pa_est[1]
n = ncol(q.matrix)
MLE_Pa_est_attiribute = classAccuracyDINA$statistics[3:(3+n-1),1]
names(MLE_Pa_est_attiribute) = paste0(rep("MLE_Pa_est_N",n),1:n)
MAP_patt_Pa_est = classAccuracyDINA$statistics$Pa_est[2]
MAP_Pa_est_attiribute = classAccuracyDINA$statistics[(2+n+1):nrow(classAccuracyDINA$statistics),1]
names(MAP_Pa_est_attiribute) = paste0(rep("MAP_Pa_est_N",n),1:n)
resultDINA[[i]] = cbind.data.frame(mean.rmsea, loglikelihood, deviance, AIC, BIC, MLE_patt_Pa_est,
t(MLE_Pa_est_attiribute), MAP_patt_Pa_est, t(MAP_Pa_est_attiribute))
### Dino Estimations
Dino<- din(data = simdata$dat, q.matrix = q.matrix, rule = "DINO", seed = seed)
summaryDINO = summary(Dino)
classAccuracyDINO = cdm.est.class.accuracy(Dino)
mean.rmsea = summaryDINO$din.object$mean.rmsea
itemfit.rmsea = summaryDINO$din.object$itemfit.rmsea
loglikelihood = summaryDINO$din.object$loglike
deviance = summaryDINO$deviance
AIC = summaryDINO$AIC
BIC = summaryDINO$BIC
MLE_patt_Pa_est = classAccuracyDINO$statistics$Pa_est[1]
n = ncol(q.matrix)
MLE_Pa_est_attiribute = classAccuracyDINO$statistics[3:(3+n-1),1]
names(MLE_Pa_est_attiribute) = paste0(rep("MLE_Pa_est_N",n),1:n)
MAP_patt_Pa_est = classAccuracyDINO$statistics$Pa_est[2]
MAP_Pa_est_attiribute = classAccuracyDINO$statistics[(2+n+1):nrow(classAccuracyDINO$statistics),1]
names(MAP_Pa_est_attiribute) = paste0(rep("MAP_Pa_est_N",n),1:n)
resultDINO[[i]] = cbind.data.frame(mean.rmsea, loglikelihood, deviance, AIC, BIC, MLE_patt_Pa_est,
t(MLE_Pa_est_attiribute), MAP_patt_Pa_est, t(MAP_Pa_est_attiribute))
}
resultsDINA = do.call(rbind.data.frame,resultDINA)
resultsDINO = do.call(rbind.data.frame,resultDINO)
pathDINA = paste0("~/Documents/Emine Yavuz/results/n_",size[s],"/DINA/Q_",attribute[k],"_",item[l],"_DINA.xlsx")
pathDINO = paste0("~/Documents/Emine Yavuz/results/n_",size[s],"/DINO/Q_",attribute[k],"_",item[l],"_DINO.xlsx")
# write.table(results, path2, quote = F, row.names = F, sep = "\t")
write.xlsx(resultsDINA, pathDINA)
write.xlsx(resultsDINO, pathDINO)
}
}
}
library(MVN)
mvn
r = mvn(iris[,1:3], multivariateOutlierMethod = "quan")
r$Descriptives
r$multivariateNormality
r = mvn(iris[,1:3], multivariateOutlierMethod = "quan", showOutliers = T)
r
r$multivariateOutliers
r = mvn(iris[,1:3], multivariateOutlierMethod = "quan", showOutliers = T, showNewData = T)
x = c(55,55,45,45)
mean(x)
y = c(55,45)
mean(y)
sd(y)
sdx
sd(x)
sqrt(0.671)
library(survival)
?survfit
data = read.table("~/Documents/GitHub/geneSurv/www/data/GSE2034.txt", header = T, sep = "\t")
survivalTime = "dmfs_time"
statusVariable = "dmfs_event"
status="1"
factors = "ER_IHC"
survivalTable = TRUE
caseSummary = TRUE
hr=TRUE
meanMedianSurvivalTimes = TRUE
quartilesOfSurvivalTimes = FALSE
ci = "log"
varianceEstimation = "greenwood"
comparisonTest = "logRank"
confidenceLevel = 95
referenceCategory = "first"
typeOfTest = "asymptotic"
kmCurve = TRUE
p= 1;q = 1; data = data
fname = factors
if(!is.null(survivalTime)){
survivalTime = as.matrix(data[, survivalTime, drop = FALSE])
survivalTime = apply(survivalTime, 2, as.numeric)
if(sum(survivalTime[,1], na.rm = T) == 0){
stop("Survival time is not a numeric variable.")
}
}
if(!is.null(factors)){
factorsName = data[, factors, drop = FALSE]
}
if(!is.null(factors)){
factors = as.factor(data[, factors])
}
if(referenceCategory != "first" && !is.null(factors)){
factors <- factor(factors, levels=rev(levels(factors)))
}
if(!is.null(statusVariable)){
statusVariable = data[, statusVariable]
}
if(!is.null(status)){
if(is.numeric(status)){status = as.factor(status)}else{status = as.factor(status)}
}
if(!is.null(factors)){
newData = data.frame(id =seq(1,dim(survivalTime)[1], 1), survivalTime= survivalTime,
statusVar=statusVariable,factor = factors)
newData = newData[complete.cases(newData),]
#newData$survivalTime = as.numeric(newData$survivalTime)
colnames(newData) = c("id", "time", "statusVar", "factor")
}else{
newData = data.frame(id =seq(1,dim(survivalTime)[1], 1), survivalTime= survivalTime,
statusVar=statusVariable)
newData = newData[complete.cases(newData),]
# newData$survivalTime = as.numeric(newData$survivalTime)
colnames(newData) = c("id", "time", "statusVar")
}
newData$statusVar = newData$statusVar%in%status
if(!is.null(factors)){
if(caseSummary){
splitFactor = split(newData, newData$factor)
caseSummary2 <- lapply(splitFactor, FUN = function(x){
if(TRUE %in% x$statusVar){
n = nrow(x)
nOfEvent =  as.numeric(table(x$statusVar)[as.factor(names(table(x$statusVar))) %in% TRUE][[1]])
percentOfEvent = as.numeric(formatC((nOfEvent/n)*100, digits = 3, format = "f"))
if(percentOfEvent == 100){
nOfCensor = as.numeric(formatC(0, digits = 3, format = "f"))
percentOfCensor = as.numeric(formatC(0, digits = 3, format = "f"))
}else{
nOfCensor =  as.numeric(table(x$statusVar)[(!(names(table(x$statusVar))) %in% TRUE)][[1]])
percentOfCensor = as.numeric(formatC((nOfCensor/n)*100, digits = 3, format = "f"))
}
caseSummary = data.frame(n,nOfEvent, percentOfEvent, nOfCensor, percentOfCensor)
colnames(caseSummary) = c("n", "n of event", "% of event", "n of censor", "% of censor")
return(caseSummary)
}else{
stop("Factor variable is not appropriate. Not enough events in at least one of the factor groups.")
}
})
}
assign("newData", newData, envir=.GlobalEnv)  # put the dat in the global env
compareCurves <- survfit(Surv(time, statusVar) ~ factor, data = newData, conf.type = ci, error = varianceEstimation, conf.int = confidenceLevel/100)
summary = summary(compareCurves, rmean = "individual")
if(survivalTable){
survivalTableResult = data.frame(summary[c(2:5,7,8,10,9)])
survivalTableResult$surv = as.numeric(formatC(summary$surv, digits = 3, format = "f"))
survivalTableResult$std.err = as.numeric(formatC(summary$std.err, digits = 3, format = "f"))
survivalTableResult$upper = as.numeric(formatC(summary$upper, digits = 3, format = "f"))
survivalTableResult$lower = as.numeric(formatC(summary$lower, digits = 3, format = "f"))
survivalTableResult = split(survivalTableResult[-5], survivalTableResult$strata)
names(survivalTableResult) = levels(factors)
}
survivalTableLastResult = lapply(survivalTableResult, function(x)
{
colnames(x) = c("Time", "Number at risk", "Number of event", "Cumulative probability of surviving", "S.E.", "Lower limit", "Upper limit")
return(x)
}
)
}else{
survivalTableLastResult = NULL
}
summary = summary(compareCurves, rmean = "individual")
summary
survivalTableResult = data.frame(summary[c(2:5,7,8,10,9)])
require(devtools)
install_version("survival", version = "2.36-1", repos = "http://cran.us.r-project.org")
library(survival)
?survfit
data = read.table("~/Documents/GitHub/geneSurv/www/data/GSE2034.txt", header = T, sep = "\t")
survivalTime = "dmfs_time"
statusVariable = "dmfs_event"
status="1"
factors = "ER_IHC"
survivalTable = TRUE
caseSummary = TRUE
hr=TRUE
meanMedianSurvivalTimes = TRUE
quartilesOfSurvivalTimes = FALSE
ci = "log"
varianceEstimation = "greenwood"
comparisonTest = "logRank"
confidenceLevel = 95
referenceCategory = "first"
typeOfTest = "asymptotic"
kmCurve = TRUE
p= 1;q = 1; data = data
fname = factors
if(!is.null(survivalTime)){
survivalTime = as.matrix(data[, survivalTime, drop = FALSE])
survivalTime = apply(survivalTime, 2, as.numeric)
if(sum(survivalTime[,1], na.rm = T) == 0){
stop("Survival time is not a numeric variable.")
}
}
if(!is.null(factors)){
factorsName = data[, factors, drop = FALSE]
}
if(!is.null(factors)){
factors = as.factor(data[, factors])
}
if(referenceCategory != "first" && !is.null(factors)){
factors <- factor(factors, levels=rev(levels(factors)))
}
if(!is.null(statusVariable)){
statusVariable = data[, statusVariable]
}
if(!is.null(status)){
if(is.numeric(status)){status = as.factor(status)}else{status = as.factor(status)}
}
if(!is.null(factors)){
newData = data.frame(id =seq(1,dim(survivalTime)[1], 1), survivalTime= survivalTime,
statusVar=statusVariable,factor = factors)
newData = newData[complete.cases(newData),]
#newData$survivalTime = as.numeric(newData$survivalTime)
colnames(newData) = c("id", "time", "statusVar", "factor")
}else{
newData = data.frame(id =seq(1,dim(survivalTime)[1], 1), survivalTime= survivalTime,
statusVar=statusVariable)
newData = newData[complete.cases(newData),]
# newData$survivalTime = as.numeric(newData$survivalTime)
colnames(newData) = c("id", "time", "statusVar")
}
newData$statusVar = newData$statusVar%in%status
if(caseSummary){
splitFactor = split(newData, newData$factor)
caseSummary <- lapply(splitFactor, FUN = function(x){
if(TRUE %in% x$statusVar){
n = nrow(x)
nOfEvent =  as.numeric(table(x$statusVar)[as.factor(names(table(x$statusVar))) %in% TRUE][[1]])
percentOfEvent = as.numeric(formatC((nOfEvent/n)*100, digits = 3, format = "f"))
if(percentOfEvent == 100){
nOfCensor = as.numeric(formatC(0, digits = 3, format = "f"))
percentOfCensor = as.numeric(formatC(0, digits = 3, format = "f"))
}else{
nOfCensor =  as.numeric(table(x$statusVar)[(!(names(table(x$statusVar))) %in% TRUE)][[1]])
percentOfCensor = as.numeric(formatC((nOfCensor/n)*100, digits = 3, format = "f"))
}
caseSummary = data.frame(n,nOfEvent, percentOfEvent, nOfCensor, percentOfCensor)
colnames(caseSummary) = c("n", "n of event", "% of event", "n of censor", "% of censor")
return(caseSummary)
}else{
stop("Factor variable is not appropriate. Not enough events in at least one of the factor groups.")
}
})
}
assign("newData", newData, envir=.GlobalEnv)  # put the dat in the global env
compareCurves <- survfit(Surv(time, statusVar) ~ factor, data = newData, conf.type = ci, error = varianceEstimation, conf.int = confidenceLevel/100)
summary = summary(compareCurves, rmean = "individual")
summary
if(survivalTable){
survivalTableResult = data.frame(summary[c(2:5,7,8,10,9)])
survivalTableResult$surv = as.numeric(formatC(summary$surv, digits = 3, format = "f"))
survivalTableResult$std.err = as.numeric(formatC(summary$std.err, digits = 3, format = "f"))
survivalTableResult$upper = as.numeric(formatC(summary$upper, digits = 3, format = "f"))
survivalTableResult$lower = as.numeric(formatC(summary$lower, digits = 3, format = "f"))
survivalTableResult = split(survivalTableResult[-5], survivalTableResult$strata)
names(survivalTableResult) = levels(factors)
}
survivalTableResult = data.frame(summary[c(2:5,7,8,10,9)])
survivalTableResult
shiny::runApp('Desktop/Covid-2019/app')
seq(1:nrow(data))
data
dataa["Count"]
data["Count"]
data[,"Count"]
runApp('Desktop/Covid-2019/app')
runApp('Desktop/Covid-2019/app')
seq(1:nrow(data))
seq(1:nrow(data))[1]
runApp('Desktop/Covid-2019/app')
runApp('Desktop/Covid-2019/app')
install.packages('rsconnect')
library(rsconnect)
library(rsconnect)
rsconnect::setAccountInfo(name='gsdstat', token='C9E0F7D168FC4BB768AB03C6696AF758', secret='8Qqbuzj4mLeHhn/9UjeLPy4b1K6ruxF9qkFYcj2L')
deployApp()
setwd("~/Desktop/Covid-2019/app/")
deployApp()
runApp()
